<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <link type="text/css" rel="stylesheet" href="styles.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
        <title>Nearby PLUTO lots</title>
    </head>
    <body>  
        <pre id = "info">Tap 'START AR' Button</pre>
        <script async src="https://unpkg.com/es-module-shims@1.4.7/dist/es-module-shims.js"></script>
        <script type="importmap">
            {
              "imports": {
                "three": "https://unpkg.com/three@0.138.0/build/three.module.js",
                "arbutton": "https://unpkg.com/three/examples/jsm/webxr/ARButton.js",
                "css2drenderer": "https://unpkg.com/three/examples/jsm/renderers/CSS2DRenderer.js"
              }
            }
          </script>
        <!--SCRIPT FOR THREE.js MODULE-->
        <script type="module">
            
            import * as THREE from 'three';
            import { ARButton } from 'arbutton';
            import { CSS2DRenderer, CSS2DObject } from 'css2drenderer';
            
            var t0 = 0;

            // import * as THREE from 'https://unpkg.com/three/build/three.module.js';
            // import { ARButton } from 'https://unpkg.com/three/examples/jsm/webxr/ARButton.js';
            // import { CSS2DRenderer, CSS2DObject } from 'https://unpkg.com/three/examples/jsm/renderers/CSS2DRenderer.js';



            // variable pointing to DOM 'info' element
            const info = document.getElementById( 'info' );

            // import { test } from './my-location.js';
            // declare container, camera, scene, renderer
            var container;
            var camera, controller, scene, renderer, labelRenderer;

            var magnet = 0;
            var objects = [];

            const pointer = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();

            // declare epsg
            const epsg_sm = 'EPSG:3857';
            const epsg_sp = '+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000.0000000001 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs';

            //determine user geolocation:
            var options = {
                    enableHighAccuracy: true,
                    maximumAge: 0
                };
            
            function success(pos) {
                var crd = pos.coords;
                // console.log(pos);
                var acc = crd.accuracy;
                // console.log(acc);
                var long = crd.longitude;
                var lat = crd.latitude;
                var coords = [long, lat]
                var sm_crds = proj4(epsg_sm, coords);
                var sp_crds = proj4(epsg_sp, coords);
                // fetch request to query postgres db for PLUTO tax lots within 50 meters of user's current location
                // unit for testing speed of loading the pluto data
                t0 = performance.now();
                // pluto loading speed
                fetch(`https://powerful-woodland-32319.herokuapp.com/db?long=${long}&lat=${lat}`)
                    .then(response => response.json())
                    .then(json => {
                        console.log(json);
                        // end of pluto loading test
                        const t1 = performance.now();
                        info.textContent = `loaded ${json.length} pluto in ${t1-t0} ms \naccuracy: ${acc} meters`;
                        // info.textContent = `accuracy: ${acc} meters`;
                        init(sm_crds, sp_crds, json);
                        animate();
                    })
            }
            
            function error(err) {
                console.warn(`ERROR(${err.code}): ${err.message}`);
            }
            
            navigator.geolocation.getCurrentPosition(success, error, [options]);

            // three.js init(), onWindowResize, animate, render functions
            
            function init(sm_crds, sp_crds, json) {

                // testing encoding the json
                var encodedGeojson = encodeURI(`${json[1].geometry}`);
                console.log(encodedGeojson);

                const once = {
                    once: true
                }

                var offset;

                function startOrient() {
                    window.addEventListener( "touchend", checkOrientation, once );
                }

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                scene = new THREE.Scene();
                const group = new THREE.Group();

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 100 );

                const light = new THREE.DirectionalLight( 0xffffff, 1 );
                // light.position.set( 0, 10, 0 );
                scene.add( light );

                //

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.xr.enabled = true;
                container.appendChild( renderer.domElement );

                // label Renderer TESTING*****************************************************************
                labelRenderer = new CSS2DRenderer();
                labelRenderer.setSize( window.innerWidth, window.innerHeight );
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                document.body.appendChild( labelRenderer.domElement );

                // END OF TESTING*************************************************************************

                document.body.appendChild( ARButton.createButton( renderer, {
                    optionalFeatures: [ 'dom-overlay', 'dom-overlay-for-handheld-ar' ],
                    domOverlay: { root: document.body }
                } ) );

                // controller

                controller = renderer.xr.getController( 0 );
                scene.add( controller );

                // initial box geometry

                var pluto_geometry = new THREE.BoxGeometry( 3, 3, 3);

                document.addEventListener( 'pointerup', startOrient, once ); 

                // check for iOS orientation and render/rotate objects as necessary

                function handleiOSOrientation(event) {
                    // info.innerText = "iOS detected"
                    var compassDir = event.webkitCompassHeading;
                    if (compassDir === 0) {
                        checkOrientation();
                    }
                    offset = compassDir * (Math.PI/180);
                    
                    // testing encoding the json
                    // var encodedGeojson = encodeURIComponent(`${json}`);
                    // console.log(encodedGeojson);

                    for (const each of json) {
                        var plutoMaterial = new THREE.MeshBasicMaterial( { color: 0x00feef } );
                        var pluto_location = new THREE.Mesh( pluto_geometry, plutoMaterial );
                        
                        // pluto_location.position.set(each.st_x-sm_crds[0], 0, sm_crds[1]-each.st_y);
                        
                        // spherical mercator positioning

                        // pluto_location.position.set(each.st_x-sm_crds[0], 0, sm_crds[1]-each.st_y).applyMatrix4( controller.matrixWorld );
                        // pluto_location.quaternion.setFromRotationMatrix( controller.matrixWorld );

                        // state plane positioning

                        pluto_location.position.set((each.st_x-sp_crds[0])*0.3048, 0, (sp_crds[1]-each.st_y)*0.3048).applyMatrix4( controller.matrixWorld );
                        pluto_location.quaternion.setFromRotationMatrix( controller.matrixWorld );

                        pluto_location.userData = Object.entries(each);
                        
                        // scene.add( pluto_location );
                        group.add( pluto_location );
                    }

                    scene.rotation.y = offset;

                    // test adding PLUTO text backing plane to scene
                    // var planeGeometry = new THREE.PlaneGeometry( 0.5, 0.5 );
                    // var textBacking = new THREE.MeshBasicMaterial( {transparent: true, opacity: 0.3, color: 0xffffff, side: THREE.DoubleSide} );
                    // var textPlane = new THREE.Mesh( planeGeometry, textBacking );
                    
                    // textPlane.position.set( -0.5, -0.25, 0 ).applyMatrix4( controller.matrixWorld );
                    // pluto_location.quaternion.setFromRotationMatrix( controller.matrixWorld );
                    // textPlane.rotateY( (90 * Math.PI) / 180 );
                    // //  
                    // // textPlane.rotation.z = ( (180 * Math.PI) / 180 );
                    // scene.add( textPlane ); 
                    // end of test
                    scene.add( group );
                }
                
                function handleOrientation(event) {
                    // info.innerText = "Android detected"
                    var alpha = event.alpha;
                    var absolute = event.absolute;
                    if (absolute != "true" && magnet === 0) {
                        magnet = 1;
                        window.addEventListener( 'pointerup', handleNonOrientation, once);
                        info.innerText = `No magnetometer detected. \nPlease face 'north' now. \nPlease tap screen to reload.`;
                    } else {
                        offset = alpha * (Math.PI/180);

                        for (const each of json) {
                            var plutoMaterial = new THREE.MeshBasicMaterial( { color: 0x00feef } );
                            var pluto_location = new THREE.Mesh( pluto_geometry, plutoMaterial );

                            pluto_location.position.set(each.st_x-sm_crds[0], 0, sm_crds[1]-each.st_y).applyMatrix4( controller.matrixWorld );
                            pluto_location.quaternion.setFromRotationMatrix( controller.matrixWorld );

                            pluto_location.userData = Object.entries(each);
                            
                            scene.add( pluto_location );
                        }
                        scene.rotation.y = -offset;
                    }
                }

                function handleNonOrientation(event) {
                    for (const each of json) {
                        var plutoMaterial = new THREE.MeshBasicMaterial( { color: 0x00feef } );
                        var pluto_location = new THREE.Mesh( pluto_geometry, plutoMaterial );
                        // pluto_location.position.set(each.st_x-sm_crds[0], 0, sm_crds[1]-each.st_y);

                        pluto_location.position.set(each.st_x-sm_crds[0], 0, sm_crds[1]-each.st_y).applyMatrix4( controller.matrixWorld );
                        pluto_location.quaternion.setFromRotationMatrix( controller.matrixWorld );

                        pluto_location.userData = Object.entries(each);
                        
                        scene.add( pluto_location );
                    }
                }

                    // checkOrientation function to decide if iPhone or Android is seeking orientation

                    // function to check orientation device type and send to appropriate orientation/rotation function

                function checkOrientation() {

                    // console.log('starting to check orientation');
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener( 'deviceorientation', handleiOSOrientation, once);
                            }
                        })
                        .catch(console.error);
                    } else {
                        window.addEventListener( 'deviceorientation', handleOrientation, once);
                    }
                }

                // document.addEventListener( 'pointerup', startOrient, once );
                document.addEventListener( 'pointerup', onTouchUp, false );
            }

            function onTouchUp( event ) {

                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                pointer.y = -( event.clientY / window.innerHeight ) * 2 + 1;
                // console.log(pointer.x, pointer.y);
                raycaster.setFromCamera( pointer, camera );
                var intersects = raycaster.intersectObjects( scene.children );
                if (intersects.length === 0) {
                    // needs to clear the div of info
                    info.innerText = 'PLUTO information displays here';
                    for (let i = 0; i < objects.length; i++) {
                        // info.innerText = objects[i].object.material.color;
                        objects[i].object.material.color.set( 0x00feef );
                        objects.pop();
                    }
                    pointer.x = null;
                    pointer.y = null;
                    // console.log(pointer.x, pointer.y);
                } else {

                    // TESTING SECTION!!

                    for (let i = 0; i < objects.length; i++) {
                            objects[i].object.material.color.set( 0x00feef );
                            objects.pop();
                    }
                    info.innerText = '';
                        
                    for ( let i = 0; i < intersects.length ; i++ ) {
                        intersects[ i ].object.material.color.set( 0xff10f0 );
                        objects.push(intersects[i]);
                        info.innerText = "nothing for now...";

                        // PLANE with TEXT TESTING:

                        const planeGeometry = new THREE.PlaneGeometry( 0.5, 0.5 );
                        const textBacking = new THREE.MeshBasicMaterial( {transparent: true, opacity: 0.3, color: 0xffffff, side: THREE.DoubleSide} );
                        const textPlane = new THREE.Mesh( planeGeometry, textBacking );
                        textPlane.position.set( 0.6, 0.3, -2 );
                        // textPlane.rotateY( -(45 * Math.PI) / 180 );
                        scene.add( textPlane );

                        const planeDiv = document.createElement( 'div' );
                        planeDiv.className = 'label';
                        planeDiv.textContent = `${Object.entries(intersects[ i ].object.userData).join("\n")}`;
                        // planeDiv.style.marginTop = '-1em';
                        // planeDiv.style.background = 'red';
                        const planeLabel = new CSS2DObject( planeDiv );
                        intersects[i].object.add( planeLabel );
                        // textPlane.add( planeLabel );
                        // planeLabel.layers.set( 1 ); 

                        //end of test



                    }
                }
            }
            
            function animate() {

                renderer.setAnimationLoop( render );

            }

            function render() {

                renderer.render( scene, camera );
                labelRenderer.render( scene, camera );

            }
        </script>    
    </body>
</html>